// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

// Code generated by MockGen. DO NOT EDIT.
// Source: fuzzing.go
//
// Generated by this command:
//
//	mockgen -source fuzzing.go -destination fuzzing_mocks.go -package fuzzing
//

// Package fuzzing is a generated GoMock package.
package fuzzing

import (
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockOperation is a mock of Operation interface.
type MockOperation[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockOperationMockRecorder[T]
}

// MockOperationMockRecorder is the mock recorder for MockOperation.
type MockOperationMockRecorder[T any] struct {
	mock *MockOperation[T]
}

// NewMockOperation creates a new mock instance.
func NewMockOperation[T any](ctrl *gomock.Controller) *MockOperation[T] {
	mock := &MockOperation[T]{ctrl: ctrl}
	mock.recorder = &MockOperationMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOperation[T]) EXPECT() *MockOperationMockRecorder[T] {
	return m.recorder
}

// Apply mocks base method.
func (m *MockOperation[T]) Apply(t TestingT, context *T) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Apply", t, context)
}

// Apply indicates an expected call of Apply.
func (mr *MockOperationMockRecorder[T]) Apply(t, context any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockOperation[T])(nil).Apply), t, context)
}

// Serialize mocks base method.
func (m *MockOperation[T]) Serialize() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Serialize")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Serialize indicates an expected call of Serialize.
func (mr *MockOperationMockRecorder[T]) Serialize() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Serialize", reflect.TypeOf((*MockOperation[T])(nil).Serialize))
}

// MockCampaign is a mock of Campaign interface.
type MockCampaign[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockCampaignMockRecorder[T]
}

// MockCampaignMockRecorder is the mock recorder for MockCampaign.
type MockCampaignMockRecorder[T any] struct {
	mock *MockCampaign[T]
}

// NewMockCampaign creates a new mock instance.
func NewMockCampaign[T any](ctrl *gomock.Controller) *MockCampaign[T] {
	mock := &MockCampaign[T]{ctrl: ctrl}
	mock.recorder = &MockCampaignMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCampaign[T]) EXPECT() *MockCampaignMockRecorder[T] {
	return m.recorder
}

// Cleanup mocks base method.
func (m *MockCampaign[T]) Cleanup(t TestingT, context *T) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Cleanup", t, context)
}

// Cleanup indicates an expected call of Cleanup.
func (mr *MockCampaignMockRecorder[T]) Cleanup(t, context any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cleanup", reflect.TypeOf((*MockCampaign[T])(nil).Cleanup), t, context)
}

// CreateContext mocks base method.
func (m *MockCampaign[T]) CreateContext(t TestingT) *T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateContext", t)
	ret0, _ := ret[0].(*T)
	return ret0
}

// CreateContext indicates an expected call of CreateContext.
func (mr *MockCampaignMockRecorder[T]) CreateContext(t any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateContext", reflect.TypeOf((*MockCampaign[T])(nil).CreateContext), t)
}

// Deserialize mocks base method.
func (m *MockCampaign[T]) Deserialize(arg0 []byte) []Operation[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Deserialize", arg0)
	ret0, _ := ret[0].([]Operation[T])
	return ret0
}

// Deserialize indicates an expected call of Deserialize.
func (mr *MockCampaignMockRecorder[T]) Deserialize(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deserialize", reflect.TypeOf((*MockCampaign[T])(nil).Deserialize), arg0)
}

// Init mocks base method.
func (m *MockCampaign[T]) Init() []OperationSequence[T] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Init")
	ret0, _ := ret[0].([]OperationSequence[T])
	return ret0
}

// Init indicates an expected call of Init.
func (mr *MockCampaignMockRecorder[T]) Init() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockCampaign[T])(nil).Init))
}

// MockTestingF is a mock of TestingF interface.
type MockTestingF struct {
	ctrl     *gomock.Controller
	recorder *MockTestingFMockRecorder
}

// MockTestingFMockRecorder is the mock recorder for MockTestingF.
type MockTestingFMockRecorder struct {
	mock *MockTestingF
}

// NewMockTestingF creates a new mock instance.
func NewMockTestingF(ctrl *gomock.Controller) *MockTestingF {
	mock := &MockTestingF{ctrl: ctrl}
	mock.recorder = &MockTestingFMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTestingF) EXPECT() *MockTestingFMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockTestingF) Add(args ...any) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Add", varargs...)
}

// Add indicates an expected call of Add.
func (mr *MockTestingFMockRecorder) Add(args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockTestingF)(nil).Add), args...)
}

// Fuzz mocks base method.
func (m *MockTestingF) Fuzz(ff any) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Fuzz", ff)
}

// Fuzz indicates an expected call of Fuzz.
func (mr *MockTestingFMockRecorder) Fuzz(ff any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fuzz", reflect.TypeOf((*MockTestingF)(nil).Fuzz), ff)
}

// MockTestingT is a mock of TestingT interface.
type MockTestingT struct {
	ctrl     *gomock.Controller
	recorder *MockTestingTMockRecorder
}

// MockTestingTMockRecorder is the mock recorder for MockTestingT.
type MockTestingTMockRecorder struct {
	mock *MockTestingT
}

// NewMockTestingT creates a new mock instance.
func NewMockTestingT(ctrl *gomock.Controller) *MockTestingT {
	mock := &MockTestingT{ctrl: ctrl}
	mock.recorder = &MockTestingTMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTestingT) EXPECT() *MockTestingTMockRecorder {
	return m.recorder
}

// Cleanup mocks base method.
func (m *MockTestingT) Cleanup(arg0 func()) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Cleanup", arg0)
}

// Cleanup indicates an expected call of Cleanup.
func (mr *MockTestingTMockRecorder) Cleanup(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cleanup", reflect.TypeOf((*MockTestingT)(nil).Cleanup), arg0)
}

// Error mocks base method.
func (m *MockTestingT) Error(args ...any) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Error", varargs...)
}

// Error indicates an expected call of Error.
func (mr *MockTestingTMockRecorder) Error(args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockTestingT)(nil).Error), args...)
}

// Errorf mocks base method.
func (m *MockTestingT) Errorf(format string, args ...any) {
	m.ctrl.T.Helper()
	varargs := []any{format}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Errorf", varargs...)
}

// Errorf indicates an expected call of Errorf.
func (mr *MockTestingTMockRecorder) Errorf(format any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{format}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Errorf", reflect.TypeOf((*MockTestingT)(nil).Errorf), varargs...)
}

// Fail mocks base method.
func (m *MockTestingT) Fail() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Fail")
}

// Fail indicates an expected call of Fail.
func (mr *MockTestingTMockRecorder) Fail() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fail", reflect.TypeOf((*MockTestingT)(nil).Fail))
}

// FailNow mocks base method.
func (m *MockTestingT) FailNow() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "FailNow")
}

// FailNow indicates an expected call of FailNow.
func (mr *MockTestingTMockRecorder) FailNow() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FailNow", reflect.TypeOf((*MockTestingT)(nil).FailNow))
}

// Failed mocks base method.
func (m *MockTestingT) Failed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Failed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Failed indicates an expected call of Failed.
func (mr *MockTestingTMockRecorder) Failed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Failed", reflect.TypeOf((*MockTestingT)(nil).Failed))
}

// Fatal mocks base method.
func (m *MockTestingT) Fatal(args ...any) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Fatal", varargs...)
}

// Fatal indicates an expected call of Fatal.
func (mr *MockTestingTMockRecorder) Fatal(args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fatal", reflect.TypeOf((*MockTestingT)(nil).Fatal), args...)
}

// Fatalf mocks base method.
func (m *MockTestingT) Fatalf(format string, args ...any) {
	m.ctrl.T.Helper()
	varargs := []any{format}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Fatalf", varargs...)
}

// Fatalf indicates an expected call of Fatalf.
func (mr *MockTestingTMockRecorder) Fatalf(format any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{format}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fatalf", reflect.TypeOf((*MockTestingT)(nil).Fatalf), varargs...)
}

// Helper mocks base method.
func (m *MockTestingT) Helper() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Helper")
}

// Helper indicates an expected call of Helper.
func (mr *MockTestingTMockRecorder) Helper() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Helper", reflect.TypeOf((*MockTestingT)(nil).Helper))
}

// Log mocks base method.
func (m *MockTestingT) Log(args ...any) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Log", varargs...)
}

// Log indicates an expected call of Log.
func (mr *MockTestingTMockRecorder) Log(args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockTestingT)(nil).Log), args...)
}

// Logf mocks base method.
func (m *MockTestingT) Logf(format string, args ...any) {
	m.ctrl.T.Helper()
	varargs := []any{format}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Logf", varargs...)
}

// Logf indicates an expected call of Logf.
func (mr *MockTestingTMockRecorder) Logf(format any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{format}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logf", reflect.TypeOf((*MockTestingT)(nil).Logf), varargs...)
}

// Name mocks base method.
func (m *MockTestingT) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockTestingTMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockTestingT)(nil).Name))
}

// Setenv mocks base method.
func (m *MockTestingT) Setenv(key, value string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Setenv", key, value)
}

// Setenv indicates an expected call of Setenv.
func (mr *MockTestingTMockRecorder) Setenv(key, value any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Setenv", reflect.TypeOf((*MockTestingT)(nil).Setenv), key, value)
}

// Skip mocks base method.
func (m *MockTestingT) Skip(args ...any) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Skip", varargs...)
}

// Skip indicates an expected call of Skip.
func (mr *MockTestingTMockRecorder) Skip(args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Skip", reflect.TypeOf((*MockTestingT)(nil).Skip), args...)
}

// SkipNow mocks base method.
func (m *MockTestingT) SkipNow() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SkipNow")
}

// SkipNow indicates an expected call of SkipNow.
func (mr *MockTestingTMockRecorder) SkipNow() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SkipNow", reflect.TypeOf((*MockTestingT)(nil).SkipNow))
}

// Skipf mocks base method.
func (m *MockTestingT) Skipf(format string, args ...any) {
	m.ctrl.T.Helper()
	varargs := []any{format}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Skipf", varargs...)
}

// Skipf indicates an expected call of Skipf.
func (mr *MockTestingTMockRecorder) Skipf(format any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{format}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Skipf", reflect.TypeOf((*MockTestingT)(nil).Skipf), varargs...)
}

// Skipped mocks base method.
func (m *MockTestingT) Skipped() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Skipped")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Skipped indicates an expected call of Skipped.
func (mr *MockTestingTMockRecorder) Skipped() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Skipped", reflect.TypeOf((*MockTestingT)(nil).Skipped))
}

// TempDir mocks base method.
func (m *MockTestingT) TempDir() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempDir")
	ret0, _ := ret[0].(string)
	return ret0
}

// TempDir indicates an expected call of TempDir.
func (mr *MockTestingTMockRecorder) TempDir() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempDir", reflect.TypeOf((*MockTestingT)(nil).TempDir))
}

// MockSerializable is a mock of Serializable interface.
type MockSerializable struct {
	ctrl     *gomock.Controller
	recorder *MockSerializableMockRecorder
}

// MockSerializableMockRecorder is the mock recorder for MockSerializable.
type MockSerializableMockRecorder struct {
	mock *MockSerializable
}

// NewMockSerializable creates a new mock instance.
func NewMockSerializable(ctrl *gomock.Controller) *MockSerializable {
	mock := &MockSerializable{ctrl: ctrl}
	mock.recorder = &MockSerializableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSerializable) EXPECT() *MockSerializableMockRecorder {
	return m.recorder
}

// Serialize mocks base method.
func (m *MockSerializable) Serialize() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Serialize")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Serialize indicates an expected call of Serialize.
func (mr *MockSerializableMockRecorder) Serialize() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Serialize", reflect.TypeOf((*MockSerializable)(nil).Serialize))
}
